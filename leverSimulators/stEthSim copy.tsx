import { buyBase, sellBase, sellFYToken, ZERO_BN } from '@yield-protocol/ui-math';
import { IInputContextState, W3bNumber } from '../context/InputContext';

import { convertToW3bNumber } from '../lib/utils';
import { ILeverContextState } from '../context/LeverContext';

import { ZERO_W3N } from '../constants';
import { NULL_OUTPUT, SimulatorOutput } from '../hooks/useLever';

import curve from '@curvefi/api';
import { ethers } from 'ethers';

import { StableSwap__factory, StEthLever__factory} from '../contracts/types';
import { IMarketContextState } from '../context/MarketContext';
import { IPositionContextState } from '../context/PositionContext';

/* Stable Swap contract */
export const WETH_STETH_STABLESWAP = '0x828b154032950c8ff7cf8085d841723db2696056';

export const stEthSimulator =  async (
  inputState: IInputContextState,
  leverState: ILeverContextState,
  marketState: IMarketContextState,
  positionsState: IPositionContextState,
  provider: ethers.providers.BaseProvider| undefined,
  currentTime: number = Math.round(new Date().getTime() / 1000)
): Promise<SimulatorOutput> => {

  const output = NULL_OUTPUT;
  const input = inputState.input || ZERO_W3N;
  const leverage = inputState.leverage;
  const lever = leverState.selectedLever;

  if (input.big.gt(ZERO_BN) && provider) {

    console.log('Fired STETH Lever....');
    /**
     * CURVE infomation :
     * */
    await curve.init('Infura', { network: 'homestead', apiKey: '2af222f674024a0f84b5f0aad0da72a2' }, { chainId: 1 });

    // --- STETH ---
    const steth = curve && curve.getPool('steth');
    // const vol = await steth.stats.volume();
    // console.log(vol);
    /*  Daily/weekly APY based on usage  */
    // const apy = await steth.stats.baseApy(); // { day: '3.1587592896017647', week: '2.6522145719060752' } (as %)
    // console.log(apy);
    /*  Token APY  */
    // const tokenApy = await steth.stats.tokenApy();
    // console.log(tokenApy);
    // [ '0.5918', '1.4796' ] ([min, max] as %)

    /* StETH APY */
    const rewardsApy = await steth.stats.rewardsApy();
    const investAPY = rewardsApy[0].apy.toString();
    // [
    //     {
    //         gaugeAddress: '0x182b723a58739a9c974cfdb385ceadb237453c28',
    //         tokenAddress: '0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32',
    //         tokenPrice: 1.023,
    //         name: 'Lido DAO Token',
    //         symbol: 'LDO',
    //         decimals: '18',
    //         apy: 2.6446376845647155 (annualised as %)
    //     }
    // ]
    const parameters = await steth.stats.parameters();
    const investFee = parameters.fee;
    // {
    //     lpTokenSupply: '66658430.461661546713781772',
    //     virtualPrice: '1.107067773320466717',
    //     fee: '0.04', // % ie. * 0.0004
    //     adminFee: '0.02',
    //     A: '4500',
    //     future_A: '4500',
    //     initial_A: undefined,
    //     future_A_time: undefined,
    //     initial_A_time: undefined,
    //     gamma: undefined
    // }

    const timeToMaturity = marketState.maturity - currentTime;
    const yearProportion = timeToMaturity / 31536000;

    const inputAsFyToken_ = sellBase(
      marketState.sharesReserves,
      marketState.fyTokenReserves,
      input.big,
      timeToMaturity.toString(),
      marketState.ts,
      marketState.g1,
      marketState.decimals
    );
    const inputAsFyToken: W3bNumber = input?.big.gt(ZERO_BN) ? convertToW3bNumber(inputAsFyToken_, 18, 6) : ZERO_W3N;

    const totalToInvest_ = inputAsFyToken.big.mul(leverage!.big).div(100);
    const totalToInvest: W3bNumber = inputAsFyToken.big.gt(ZERO_BN)
      ? convertToW3bNumber(totalToInvest_, 18, 6)
      : ZERO_W3N;

    const toBorrow_ = totalToInvest.big.sub(inputAsFyToken.big);
    const toBorrow: W3bNumber = inputAsFyToken ? convertToW3bNumber(toBorrow_, 18, 6) : ZERO_W3N;

    /**
     * Start Compute of how much collateral would be generated by investing with these
     * parameters.
     */
    if (inputAsFyToken.big.gt(ZERO_BN)) {
      // - netInvestAmount = baseAmount + borrowAmount - fee
      // const fyWeth = await getFyToken(seriesId, contracts, account);
      const fyContract = lever?.investTokenContract;
      const fee = ZERO_BN; //  await fyContract.flashFee(fyContract.address, toBorrow.big.toString()) ;

      output.flashBorrowFee = convertToW3bNumber(fee, 18, 6);

      /* calculate the resulting debt */
      const debt_ = buyBase(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        toBorrow.big,
        timeToMaturity.toString(),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      output.debtAtMaturity = convertToW3bNumber(debt_, 18, 6);

      // - sellFyWeth: FyWEth -> WEth
      // const obtainedWEth = await selectedLever.marketContract.sellFYTokenPreview(netInvestAmount);
      const netInvestAmount = inputAsFyToken.big.add(toBorrow.big); // .sub(fee); // - netInvestAmount = baseAmount + borrowAmount - fee
      const wethObtained = sellFYToken(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        netInvestAmount,
        timeToMaturity.toString(),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );

      output.shortBorrowed = toBorrow;
      output.shortInvested = convertToW3bNumber(wethObtained, 18, 6);
      output.investmentFee = convertToW3bNumber(output.shortInvested.big.mul(4).div(10000), 18, 6);

      const stableSwap = StableSwap__factory.connect(WETH_STETH_STABLESWAP, provider)
      const boughtStEth = await stableSwap.get_dy(0, 1, wethObtained); // .catch(()=>{console.log('too big'); return ZERO_BN} );

      // investPosition (stEth held)
      output.investmentPosition = convertToW3bNumber(boughtStEth, 18, 6);

      /* added rewards */
      const rewards = parseFloat(investAPY || '0') * yearProportion;
      const returns = ethers.utils.parseEther((output.investmentPosition.dsp * (1 + rewards / 100)).toString());
      const returnsLessFees = returns.sub(output.investmentFee.big);

      // const stEthPlusReturns = boughtStEth.mul(returns)
      output.investmentAtMaturity = convertToW3bNumber(returnsLessFees, 18, 6);

      /* check for any swapping costs */
      /* Calculate the value of the investPosition in short terms : via swap */
      const investValue_ = await stableSwap.get_dy(1, 0, boughtStEth) // .catch(()=>{console.log('failed'); return ZERO_BN} );
      const investValueLessFees = investValue_.sub(output.investmentFee.big)
      output.investmentCurrent = convertToW3bNumber(investValueLessFees, 18, 6);
    }
  }

  console.log( output)

  return output;

  // return {
  //   shortBorrowed,
  //   debtAtMaturity,
  //   debtCurrent,

  //   shortInvested,
  //   investmentPosition,
  //   investmentAtMaturity,
  //   investmentCurrent,

  //   flashBorrowFee,
  //   investmentFee,

  //   investArgs: [lever?.seriesId, input.big, ZERO_BN ],
  //   divestArgs: [lever?.seriesId, input.big, ZERO_BN ],

  //   notification: undefined,
  // };

  // /**
  //  * Compute how much short asset ( WEth ) the user has at the end of the operation. Currently and at Maturity.
  //  */
  // const simulateReturn = async (): Promise<W3bNumber> => {
  //   setIsSimulating(true);

  //   const fyContract = selectedLever.investTokenContract;
  //   const wStEthContract = contractFactories[WST_ETH].connect(WST_ETH, provider);
  //   const pool = selectedLever.poolContract;
  //   const stableSwap = contractFactories[WETH_STETH_STABLESWAP].connect(WETH_STETH_STABLESWAP, provider);

  //   if (selectedLever && selectedPosition) {
  //     /* amount of steth recieved from unwrapping wSTETH */
  //     const stEthUnwrapped = await wStEthContract.getStETHByWstETH(selectedPosition.ink);
  //     /* Amount of Eth from swapping stETH on curve */
  //     const wethReceived = await stableSwap.get_dy(1, 0, stEthUnwrapped);

  //     /* Add in any fee for flashBorrowing */
  //     const fee = ZERO_BN; // await fyContract.flashFee(fyContract.address, selectedPosition.art) ;
  //     const borrowAmountPlusFee = fee.add(selectedPosition.art);

  //     const wethToTransfer = await pool.buyFYTokenPreview(borrowAmountPlusFee);
  //     const wethRemaining = wethReceived.sub(wethToTransfer);

  //     console.log('Weth returned: ', wethRemaining.toString());
  //     // const wethRemaining = ZERO_BN;

  //     setIsSimulating(false);

  //     return convertToW3bNumber(wethRemaining, 18, 6);
  //   } else {
  //     // Past maturity, we close.
  //     // const cauldron = getContract(CAULDRON, contracts, account);
  //     // // `debtToBase` is not view, so we need to compute it ourselves
  //     // const base = await cauldron.callStatic.debtToBase(
  //     //   vault.seriesId,
  //     //   balance.art
  //     // );
  //     // const stEthUnwrapped = await wStEth.getStETHByWstETH(balance.ink);
  //     // const weth = await stableSwap.get_dy(1, 0, stEthUnwrapped);
  //     // const wethJoin = getContract(WETH_JOIN, contracts, account);
  //     console.log('TODO: handle post maturity!');
  //     setIsSimulating(false);
  //     return ZERO_W3N;
  //   }
  // };
};
