import { buyBase, sellBase, sellFYToken, ZERO_BN } from '@yield-protocol/ui-math';
import { IInputContextState } from '../context/InputContext';

import { convertToW3bNumber } from '../lib/utils';
import { ILeverContextState } from '../context/LeverContext';

import { ZERO_W3N } from '../constants';
import { SimulatorOutput, Simulator } from '../hooks/useLever';

import curve from '@curvefi/api';
import { ethers } from 'ethers';

import { StableSwap__factory } from '../contracts/types';
import { IMarketContextState } from '../context/MarketContext';
import { IPositionContextState } from '../context/PositionContext';
import { Provider, W3bNumber } from '../lib/types';

/* Stable Swap Contract */
export const STETH_STABLESWAP = '0x828b154032950c8ff7cf8085d841723db2696056';

export const stEthSimulator: Simulator = async (
  inputState: IInputContextState,
  leverState: ILeverContextState,
  marketState: IMarketContextState,
  positionState: IPositionContextState,
  provider: Provider,
  currentTime: number = Math.round(new Date().getTime() / 1000)
): Promise<SimulatorOutput | undefined> => {
  const input = inputState.input || ZERO_W3N;
  const leverage = inputState.leverage;
  const selectedLever = leverState.selectedLever;
  const selectedPosition = positionState.selectedPosition;

  const output = {} as SimulatorOutput;

  if (input.big.gt(ZERO_BN) && provider) {
    console.log('Fired STETH Lever....');
    /**
     * CURVE infomation:
     * */
    await curve.init('Infura', { network: 'homestead', apiKey: '2af222f674024a0f84b5f0aad0da72a2' }, { chainId: 1 });

    /* StETH APY */
    const steth = curve && curve.getPool('steth');
    const rewardsApy = await steth.stats.rewardsApy();
    const investAPY = rewardsApy[0].apy.toString();
    const parameters = await steth.stats.parameters();
    const investFee = parameters.fee;

    const timeToMaturity = marketState.maturity - currentTime;
    const yearProportion = timeToMaturity / 31536000;

    /* Calculate the fyToken value of the base added (input) */
    const inputAsFyToken_ = sellBase(
      marketState.sharesReserves,
      marketState.fyTokenReserves,
      input.big,
      timeToMaturity.toString(),
      marketState.ts,
      marketState.g1,
      marketState.decimals
    );
    const inputAsFyToken: W3bNumber = input?.big.gt(ZERO_BN) ? convertToW3bNumber(inputAsFyToken_, 18, 3) : ZERO_W3N;

    /* Calcualte the required total fytoken investment from the leverage */
    const totalFyToken_ = inputAsFyToken.big.mul(leverage!.big).div(100);
    const totalFyToken: W3bNumber = inputAsFyToken.big.gt(ZERO_BN)
      ? convertToW3bNumber(totalFyToken_, 18, 3)
      : ZERO_W3N;

    /* Calculate the extra amount needed to be borrowed to get to the required fytoken investmeent */
    const borrowAmount_ = totalFyToken.big.sub(inputAsFyToken.big);
    const borrowAmount: W3bNumber = inputAsFyToken ? convertToW3bNumber(borrowAmount_, 18, 3) : ZERO_W3N;

    output.shortAssetBorrowed = borrowAmount;

    /**
     * Compute how much collateral would be generated by investing with these parameters.
     */
    if (inputAsFyToken.big.gt(ZERO_BN)) {
      // - netInvestAmount = baseAmount + borrowAmount - fee
      // const fyWeth = await getFyToken(seriesId, contracts, account);
      const fyContract = selectedLever?.fyTokenContract;
      const fee = ZERO_BN; //  await fyContract.flashFee(fyContract.address, toBorrow.big.toString()) ;

      output.flashBorrowFee = convertToW3bNumber(fee, 18, 3);

      /* Calculate the total investment after selling all accumulated FyWEth for base */
      const netFytoken = totalFyToken.big; // .sub(fee); // netFytoken = baseAmount + borrowAmount - flash fee
      const shortObtained_ = sellFYToken(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        netFytoken,
        timeToMaturity.toString(),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      output.shortAssetObtained = convertToW3bNumber(shortObtained_, 18, 3);

      /* Calculate the resulting debt from the amount borrowed */
      const debtAtMaturity_ = buyBase(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        borrowAmount.big,
        timeToMaturity.toString(),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      output.debtAtMaturity = convertToW3bNumber(debtAtMaturity_, 18, 3);

      /* Investment */
      output.investmentFee = convertToW3bNumber(output.shortAssetObtained.big.mul(4).div(10000), 18, 3);

      const stableSwap = StableSwap__factory.connect(STETH_STABLESWAP, provider);
      const boughtStEth = await stableSwap.get_dy(0, 1, shortObtained_); // .catch(()=>{console.log('too big'); return ZERO_BN} );

      // investPosition (stEth held)
      output.longAssetObtained = convertToW3bNumber(boughtStEth, 18, 3);

      /* added rewards */
      const rewards = parseFloat(investAPY || '0') * yearProportion;
      const returns = ethers.utils.parseEther((output.longAssetObtained.dsp * (1 + rewards / 100)).toString());
      const returnsLessFees = returns.sub(output.investmentFee.big);

      // const stEthPlusReturns = boughtStEth.mul(returns)
      output.investmentAtMaturity = convertToW3bNumber(returnsLessFees, 18, 3);

      /* check for any swapping costs */
      /* Calculate the value of the investPosition in short terms : via swap */
      const investValue_ = await stableSwap.get_dy(1, 0, boughtStEth); // .catch(()=>{console.log('failed'); return ZERO_BN} );
      const investValueLessFees = investValue_.sub(output.investmentFee.big);
      output.investmentCurrent = convertToW3bNumber(investValueLessFees, 18, 3);
    }

    /** INVEST :
     *  bytes6 seriesId, // series id
     * uint256 baseAmount, // base amount added
     * uint256 borrowAmount,  // extra base required
     * uint256 minWeth  // minCollateral to end up with
     * */
    output.investArgs = selectedLever
      ? [selectedLever.seriesId, input.big, output.shortAssetBorrowed.big, ZERO_BN]
      : [];

    /** DIVEST : bytes12 vaultId, bytes6 seriesId, uint256 ink,uint256 art, uint256 minWeth */
    output.divestArgs = selectedPosition
      ? [
          selectedPosition.vaultId,
          selectedPosition.seriesId,
          selectedPosition.ink.big,
          selectedPosition.art.big,
          ZERO_BN,
        ]
      : [];

    return output;
  }
  return undefined;
};
