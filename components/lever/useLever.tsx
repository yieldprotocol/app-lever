import { BigNumber, ethers, utils } from 'ethers';
import { zeroPad } from 'ethers/lib/utils';
import { useContext, useMemo, useState } from 'react';
import { WSTETH } from '../../config/assets';
import { InputContext } from '../../context/InputContext';
import { LeverContext } from '../../context/LeverContext';

export const useLever = () => {
  /* Bring in context*/
  const [leverState] = useContext(LeverContext);
  const [inputState] = useContext(InputContext);

  const { contracts, selectedStrategy, assets } = leverState;
  const { input, leverage } = leverState;

  // Use `useMemo` here because every BigNumber will be different while having
  // the same value. That means that effects will be triggered continuously.
  const totalToInvest = useMemo(() => input.big.mul(leverage.big).div(100), [input.big, leverage.big]);
  const toBorrow = useMemo(() => totalToInvest.sub(input.big), [totalToInvest, input.big]);

  /**
   * Compute how much collateral would be generated by investing with these
   * parameters. TODO generalise for any collateral
   */
  const computeStEthCollateral = async (
    baseAmount: BigNumber,
    toBorrow: BigNumber
    // contracts: MutableRefObject<Contracts>,
    // account: Signer,
    // seriesId: string
  ): Promise<BigNumber> => {
    // const fyWeth = await getFyToken(seriesId, contracts, account);
    const fyWeth = selectedStrategy.investedTokenContract;
    const fee = await fyWeth.flashFee(fyWeth.address, toBorrow);
    const netInvestAmount = baseAmount.add(toBorrow).sub(fee); // - netInvestAmount = baseAmount + borrowAmount - fee

    // - sellFyWeth: FyWEth -> WEth
    const obtainedWEth = await selectedStrategy.marketContract.sellFYTokenPreview(netInvestAmount);

    // - stableSwap exchange: WEth -> StEth
    // const stableswap = getContract(WETH_ST_ETH_STABLESWAP, contracts, account);
    const stableswap = selectedStrategy.swapContract;
    const boughtStEth = await stableswap.get_dy(0, 1, obtainedWEth);

    // - Wrap: StEth -> WStEth
    // const wStEth = getContract(WST_ETH, contracts, account);
    const wStEth = assets.get(WSTETH).assetContract;
    const wrapped = await wStEth.getWstETHByStETH(boughtStEth);

    return wrapped;
  };

  const getCauldronDebt = async () =>
    //  contracts: MutableRefObject<Contracts>,
    // account: Signer,
    // strategy: Strategy
    {
      // const cauldron = getContract(CAULDRON, contracts, account);
      return await contracts.cauldron.debt(selectedStrategy.baseId, selectedStrategy.ilkId);
    };

  const GAS_PRICE = ethers.utils.parseUnits('100', 'gwei');
  const UNITS_LEVERAGE = 2;

  /**
   * Same functionality as the vaultlevel function in cauldron. If this returns
   * a negative number, the vault would be undercollateralized.
   */
  const vaultLevel = async (
    ink: BigNumber,
    art: BigNumber
    // contracts: MutableRefObject<Contracts>,
    // account: Signer,
    // strategy: Strategy
  ): Promise<BigNumber> => {
    // const cauldron = getContract(CAULDRON, contracts, account);
    const spotOracle = await contracts.cauldron.spotOracles(selectedStrategy.baseId, selectedStrategy.ilkId);
    const ratio = BigNumber.from(spotOracle.ratio).mul(BigNumber.from(10).pow(12));
    const inkValue = (
      await selectedStrategy.oracleContract.peek(
        utils.concat([selectedStrategy.ilkId, zeroPad([], 32 - 6)]),
        utils.concat([selectedStrategy.baseId, zeroPad([], 32 - 6)]),
        ink
      )
    ).value;
    return inkValue.sub(art.mul(ratio).div(BigNumber.from(10).pow(18)));
  };

  const DEFAULT_LEVERAGE = BigNumber.from(300);

  const OPTIONS: { value: number; label: string }[] = [
    { value: 1, label: '0.1%' },
    { value: 5, label: '0.5%' },
    { value: 10, label: '1%' },
    { value: 50, label: '5%' },
  ];
  const SLIPPAGE_OPTIONS = OPTIONS;
  const [slippage, setSlippage] = useState(SLIPPAGE_OPTIONS[1].value);

  const changeSlippage = (value: number) => setSlippage(value * 10); // check

  const addSlippage = (num: BigNumber, slippage: number) => num.mul(1000 + slippage).div(1000);
  const removeSlippage = (num: BigNumber, slippage: number) => num.mul(1000 - slippage).div(1000);

  return {
    getCauldronDebt,
    computeStEthCollateral,
    vaultLevel,

    DEFAULT_LEVERAGE,
    UNITS_LEVERAGE,
    GAS_PRICE,

    slippage,
    setSlippage,
    changeSlippage,
    addSlippage,
    removeSlippage,
  };
};
