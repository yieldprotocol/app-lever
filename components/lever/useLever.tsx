import { BigNumber, ethers, Signer, utils } from 'ethers';
import { zeroPad } from 'ethers/lib/utils';
import { MutableRefObject, useMemo, useState } from 'react';
import {
  CAULDRON,
  Contracts,
  getFyToken,
  getPool,
  getContract,
  WETH_ST_ETH_STABLESWAP,
  WST_ETH,
} from '../../contracts';
import { IOracle__factory } from '../../contracts/YieldStEthLever.sol';
import { InvestTokenType, Strategy } from '../../objects/Strategy';

export const useLever = () => {

  /**
   * Compute how much collateral would be generated by investing with these
   * parameters. TODO generalise for any collateral
   */
  const computeStEthCollateral = async (
    baseAmount: BigNumber,
    toBorrow: BigNumber,
    contracts: MutableRefObject<Contracts>,
    account: Signer,
    seriesId: string
  ): Promise<BigNumber> => {
    // - netInvestAmount = baseAmount + borrowAmount - fee
    const fyWeth = await getFyToken(seriesId, contracts, account);
    const fee = await fyWeth.flashFee(fyWeth.address, toBorrow);
    const netInvestAmount = baseAmount.add(toBorrow).sub(fee);
    // - sellFyWeth: FyWEth -> WEth
    const pool = await getPool(seriesId, contracts, account);
    const obtainedWEth = await pool.sellFYTokenPreview(netInvestAmount);
    // - stableSwap exchange: WEth -> StEth
    const stableswap = getContract(WETH_ST_ETH_STABLESWAP, contracts, account);
    const boughtStEth = await stableswap.get_dy(0, 1, obtainedWEth);
    // - Wrap: StEth -> WStEth
    const wStEth = getContract(WST_ETH, contracts, account);
    const wrapped = await wStEth.getWstETHByStETH(boughtStEth);
    return wrapped;
  };

  const getCauldronDebt = async (contracts: MutableRefObject<Contracts>, account: Signer, strategy: Strategy) => {
    const cauldron = getContract(CAULDRON, contracts, account);
    return await cauldron.debt(strategy.baseId, strategy.ilkId);
  };

  const GAS_PRICE = ethers.utils.parseUnits('100', 'gwei');
  const UNITS_LEVERAGE = 2;

  /**
   * Same functionality as the vaultlevel function in cauldron. If this returns
   * a negative number, the vault would be undercollateralized.
   */
  const vaultLevel = async (
    ink: BigNumber,
    art: BigNumber,
    contracts: MutableRefObject<Contracts>,
    account: Signer,
    strategy: Strategy
  ): Promise<BigNumber> => {
    const cauldron = getContract(CAULDRON, contracts, account);
    const spotOracle = await cauldron.spotOracles(strategy.baseId, strategy.ilkId);
    const ratio = BigNumber.from(spotOracle.ratio).mul(BigNumber.from(10).pow(12));
    const inkValue = (
      await IOracle__factory.connect(spotOracle.oracle, account).peek(
        utils.concat([strategy.ilkId, zeroPad([], 32 - 6)]),
        utils.concat([strategy.baseId, zeroPad([], 32 - 6)]),
        ink
      )
    ).value;
    return inkValue.sub(art.mul(ratio).div(BigNumber.from(10).pow(18)));
  };

  const DEFAULT_LEVERAGE = BigNumber.from(300);

  const resolveInvestToken = (
    tokenType: InvestTokenType,
    seriesId: string,
    contracts: MutableRefObject<Contracts>,
    signer: Signer
  ) => {
    switch (tokenType) {
      case InvestTokenType.FyToken:
        return getFyToken(seriesId, contracts, signer);
    }
  };


  const OPTIONS: { value: number; label: string }[] = [
    { value: 1, label: "0.1%" },
    { value: 5, label: "0.5%" },
    { value: 10, label: "1%" },
    { value: 50, label: "5%" },
  ];
  
const SLIPPAGE_OPTIONS = OPTIONS;
const [slippage, setSlippage ] = useState(SLIPPAGE_OPTIONS[1].value);

const addSlippage = (num: BigNumber, slippage: number) =>
  num.mul(1000 + slippage).div(1000);

const removeSlippage = (num: BigNumber, slippage: number) =>
  num.mul(1000 - slippage).div(1000);

  return {
    getCauldronDebt,
    computeStEthCollateral,
    resolveInvestToken,
    vaultLevel,

    DEFAULT_LEVERAGE,
    UNITS_LEVERAGE,
    GAS_PRICE,
    
    slippage,
    addSlippage,
    removeSlippage
  };
};
