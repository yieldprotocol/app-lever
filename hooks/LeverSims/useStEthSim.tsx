import { useContext, useMemo, useState } from 'react';
import { sellBase, sellFYToken, ZERO_BN } from '@yield-protocol/ui-math';
import { contractFactories } from '../../config/contractRegister';
import {  InputContext, W3bNumber } from '../../context/InputContext';

import { IPoolState, MarketContext } from '../../context/MarketContext';
import { convertToW3bNumber, getTimeToMaturity } from '../../lib/utils';
import { LeverContext } from '../../context/LeverContext';
import { WETH_ST_ETH_STABLESWAP, WST_ETH } from '../../contracts';
import { ZERO_W3N } from '../../constants';
import { LeverSimulation, simOutput } from '../useLever';




export const useStEthSim = ( ): simOutput => {
  const [ leverState ] = useContext(LeverContext);
  const [ marketState ]: [IPoolState] = useContext(MarketContext);
  const { selectedStrategy, provider } = leverState;

  const [ inputState ] = useContext(InputContext);
  const { input, leverage } = inputState

  const [isSimulating, setIsSimulating] = useState<boolean>(false);

  // const [investPosition, setInvestPosition] = useState<W3bNumber>();
  // const [investValue, setInvestValue] = useState<W3bNumber>();
  // const [shortInvested, setShortInvested] = useState<W3bNumber>();
  // const [shortBorrowed, setShortBorrowed] = useState<W3bNumber>();
  // const [debtPosition, setDebtPosition] = useState<W3bNumber>();
  // const [debtValue, setDebtValue] = useState<W3bNumber>();
  // const [flashFee, setFlashFee] = useState<W3bNumber>();
  // const [swapFee, setSwapFee] = useState<W3bNumber>();

  const inputAsFyToken: W3bNumber = useMemo(() => {
    if (input && input.big.gt(ZERO_BN)) {
      const fyTokens = sellBase(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        input.big,
        getTimeToMaturity(marketState.maturity),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      return convertToW3bNumber(fyTokens, 18, 6);
    }
    return ZERO_W3N;
  }, [input, marketState]);

  const totalToInvest: W3bNumber = useMemo(() => {
    if (inputAsFyToken.big.gt(ZERO_BN)) {
      const total_ = inputAsFyToken.big.mul(leverage!.big).div(100);
      return convertToW3bNumber(total_, 18, 6); /* set as w3bnumber  */
    }
    return ZERO_W3N;
  }, [inputAsFyToken, leverage]);

  const toBorrow: W3bNumber = useMemo(() => {
    if (inputAsFyToken) {
      const toBorrow_ = totalToInvest.big.sub(inputAsFyToken.big);
      return convertToW3bNumber(toBorrow_, 18, 6); /* set as w3bNumber */
    }
    return ZERO_W3N;
  }, [totalToInvest]);


  /**
   * Compute how much collateral would be generated by investing with these
   * parameters.
   */
  const simulateLever =  async (): Promise<LeverSimulation> => {
    
    const shortBorrowed = toBorrow;
    let investPosition = ZERO_W3N;
    let investValue= ZERO_W3N;
    let shortInvested= ZERO_W3N;
    let flashFee= ZERO_W3N;
    let debtPosition= ZERO_W3N;
    let debtValue= ZERO_W3N;

    if (selectedStrategy && inputAsFyToken.big.gt(ZERO_BN) ) {

      setIsSimulating(true);

      // - netInvestAmount = baseAmount + borrowAmount - fee
      // const fyWeth = await getFyToken(seriesId, contracts, account);
      const fyContract = selectedStrategy.investTokenContract;
      const fee = await fyContract.flashFee(fyContract.address, toBorrow.big.toString());
      flashFee = convertToW3bNumber(fee.toString(), 18, 6);
      
      /* calculate the resulting debt */
      const debt_ = sellBase(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        toBorrow.big,
        getTimeToMaturity(marketState.maturity),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      debtPosition = convertToW3bNumber(debt_, 18, 6)

      // - sellFyWeth: FyWEth -> WEth
      // const obtainedWEth = await selectedStrategy.marketContract.sellFYTokenPreview(netInvestAmount);
      const netInvestAmount = inputAsFyToken.big.add(toBorrow.big).sub(fee); // - netInvestAmount = baseAmount + borrowAmount - fee
      const wethObtained = sellFYToken(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        netInvestAmount,
        getTimeToMaturity(marketState.maturity),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      shortInvested = convertToW3bNumber(wethObtained, 18, 6);

      // stableSwap exchange: WEth -> StEth
      const stableSwap = contractFactories[WETH_ST_ETH_STABLESWAP].connect(WETH_ST_ETH_STABLESWAP, provider);
      const boughtStEth = await stableSwap.get_dy(0, 1, wethObtained);

      // - Wrap: StEth -> WStEth
      const wStEthContract = contractFactories[WST_ETH].connect(WST_ETH, provider);
      const investPosition_ = await wStEthContract.getWstETHByStETH(boughtStEth);
      investPosition = convertToW3bNumber(investPosition_, 18, 6);

      // TODO check if there is a fee/cost for unwrapping */

      /* Calculate the value of the investPosition in short terms : via swap */
      const investValue_ = await stableSwap.get_dy(1, 0, boughtStEth);
      investValue = convertToW3bNumber(investValue_, 18, 6)
    }

    setIsSimulating(false);
    return {
      investPosition,
      investValue,
      shortBorrowed,
      shortInvested,
      flashFee,
      debtPosition,
      debtValue
    }
  };

  return { simulateLever, isSimulating }

};
