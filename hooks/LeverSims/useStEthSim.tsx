import { useContext, useMemo, useState } from 'react';
import { sellBase, sellFYToken, ZERO_BN } from '@yield-protocol/ui-math';
import { contractFactories } from '../../config/contractRegister';
import { InputContext, W3bNumber } from '../../context/InputContext';

import { IPoolState, MarketContext } from '../../context/MarketContext';
import { convertToW3bNumber, getTimeToMaturity } from '../../lib/utils';
import { LeverContext } from '../../context/LeverContext';
import { WETH_STETH_STABLESWAP, WST_ETH } from '../../contracts';
import { ZERO_W3N } from '../../constants';
import { LeverSimulation, simOutput } from '../useLever';
import { BigNumber, ethers } from 'ethers';

export const useStEthSim = (): simOutput => {
  const [leverState] = useContext(LeverContext);
  const [marketState]: [IPoolState] = useContext(MarketContext);
  const { selectedStrategy, provider } = leverState;
  const [inputState] = useContext(InputContext);
  // const { input, leverage } = inputState;

  const [isSimulating, setIsSimulating] = useState<boolean>(false);

  const inputAsFyToken: W3bNumber = useMemo(() => {
    if (inputState?.input && inputState?.input.big.gt(ZERO_BN)) {
      const fyTokens = sellBase(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        inputState.input.big,
        getTimeToMaturity(marketState.maturity),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      return convertToW3bNumber(fyTokens, 18, 6);
    }
    return ZERO_W3N;
  }, [inputState, marketState]);

  const totalToInvest: W3bNumber = useMemo(() => {
    if (inputAsFyToken.big.gt(ZERO_BN)) {
      const total_ = inputAsFyToken.big.mul(inputState?.leverage!.big).div(100);
      return convertToW3bNumber(total_, 18, 6); /* set as w3bnumber  */
    }
    return ZERO_W3N;
  }, [inputAsFyToken, inputState]);

  const toBorrow: W3bNumber = useMemo(() => {
    if (inputAsFyToken) {
      const toBorrow_ = totalToInvest.big.sub(inputAsFyToken.big);
      return convertToW3bNumber(toBorrow_, 18, 6); /* set as w3bNumber */
    }
    return ZERO_W3N;
  }, [totalToInvest]);

  /**
   * Compute how much collateral would be generated by investing with these
   * parameters.
   */
  const simulateInvest = async (): Promise<LeverSimulation> => {
    const shortBorrowed = toBorrow;
    
    let investPosition = ZERO_W3N;
    let investValue = ZERO_W3N;
    let shortInvested = ZERO_W3N;
    let flashFee = ZERO_W3N;
    let debtPosition = ZERO_W3N;
    let debtValue = ZERO_W3N;

    if (selectedStrategy && inputAsFyToken.big.gt(ZERO_BN)) {
      setIsSimulating(true);
      // - netInvestAmount = baseAmount + borrowAmount - fee
      // const fyWeth = await getFyToken(seriesId, contracts, account);
      const fyContract = selectedStrategy.investTokenContract;
      const fee = await fyContract.flashFee(fyContract.address, toBorrow.big.toString());
      flashFee = convertToW3bNumber(fee.toString(), 18, 6);

      /* calculate the resulting debt */
      const debt_ = sellBase(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        toBorrow.big,
        getTimeToMaturity(marketState.maturity),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      debtPosition = convertToW3bNumber(debt_, 18, 6);


      // - sellFyWeth: FyWEth -> WEth
      // const obtainedWEth = await selectedStrategy.marketContract.sellFYTokenPreview(netInvestAmount);
      const netInvestAmount = inputAsFyToken.big.add(toBorrow.big); // .sub(fee); // - netInvestAmount = baseAmount + borrowAmount - fee
      const wethObtained = sellFYToken(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        netInvestAmount,
        getTimeToMaturity(marketState.maturity),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      shortInvested = convertToW3bNumber(wethObtained, 18, 6);

      // stableSwap exchange: WEth -> StEth
      const stableSwap = contractFactories[WETH_STETH_STABLESWAP].connect(WETH_STETH_STABLESWAP, provider);
      const boughtStEth = await stableSwap.get_dy(0, 1, wethObtained);

      // investPosition (stEth held)
      investPosition = convertToW3bNumber(boughtStEth, 18, 6);

      // - Wrap: StEth -> WStEth
      const wStEthContract = contractFactories[WST_ETH].connect(WST_ETH, provider);
      // const investPosition_ = await wStEthContract.getWstETHByStETH(boughtStEth);
      // console.log( 'WrappedStETH : ',  investPosition_.toString() )

      // check unwrapping  */
      const oneStEth = ethers.utils.parseUnits('1');
      const stEthPerWrapped = await wStEthContract.getStETHByWstETH(oneStEth);
      const unwrappedStEthValue = boughtStEth.mul(stEthPerWrapped).div(oneStEth);

      // console.log(stEthPerWrapped.toString());
      // console.log('UNWRAPEED STEEHT : ', unwrappedStEthValue.toString());

      /* check for anywswapping cost */
      /* Calculate the value of the investPosition in short terms : via swap */
      const investValue_ = await stableSwap.get_dy(1, 0, unwrappedStEthValue);
      investValue = convertToW3bNumber(investValue_, 18, 6);
    }

    setIsSimulating(false);

    return {
      investPosition,
      investValue,
      shortBorrowed,
      shortInvested,
      flashFee,
      debtPosition,
      debtValue,
    };
  };

  /**
   * Compute how much WEth the user has at the end of the operation.
   */
  const simulateReturn = async ( ink: BigNumber , art: BigNumber ): Promise<W3bNumber> => {
    
    setIsSimulating(false);

    const fyContract = selectedStrategy.investTokenContract;
    const wStEthContract = contractFactories[WST_ETH].connect(WST_ETH, provider);
    const pool = selectedStrategy.poolContract;
    const stableSwap = contractFactories[WETH_STETH_STABLESWAP].connect(WETH_STETH_STABLESWAP, provider);

    // const balance = { ink: '12', art: '2' };

    if (selectedStrategy && art.gt(ZERO_BN)) {
  
      const stEthUnwrapped = await wStEthContract.getStETHByWstETH(ink);
      const wethReceived = await stableSwap.get_dy(1, 0, stEthUnwrapped);
      const fee = await fyContract.flashFee(fyContract.address, art);
      const borrowAmountPlusFee = fee.add(art);

      console.log( borrowAmountPlusFee);
      
      // const wethToTran = await pool.buyFYTokenPreview(borrowAmountPlusFee);
      // const wethRemaining = wethReceived.sub(wethToTran);  
      const wethRemaining = ZERO_BN;


      setIsSimulating(false);
      return convertToW3bNumber(wethRemaining, 18, 6);

    } else {
      // Past maturity, we close.
      // const cauldron = getContract(CAULDRON, contracts, account);
      // // `debtToBase` is not view, so we need to compute it ourselves
      // const base = await cauldron.callStatic.debtToBase(
      //   vault.seriesId,
      //   balance.art
      // );
      // const stEthUnwrapped = await wStEth.getStETHByWstETH(balance.ink);
      // const weth = await stableSwap.get_dy(1, 0, stEthUnwrapped);
      // const wethJoin = getContract(WETH_JOIN, contracts, account);
      // const fee = await wethJoin.flashFee(WETH, base);
      console.log('TODO: handle post maturity!');
      setIsSimulating(false);
      return ZERO_W3N;
    }

  };

  return { simulateReturn, simulateInvest, isSimulating, notification: [], extraBucket: [] };
};
