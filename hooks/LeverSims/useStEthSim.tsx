import { useContext, useMemo, useState } from 'react';
import { sellBase, sellFYToken, ZERO_BN } from '@yield-protocol/ui-math';
import { contractFactories } from '../../config/contractRegister';
import {  InputContext, W3bNumber } from '../../context/InputContext';

import { IPoolState, MarketContext } from '../../context/MarketContext';
import { convertToW3bNumber, getTimeToMaturity } from '../../lib/utils';
import { LeverContext } from '../../context/LeverContext';
import { WETH_STETH_STABLESWAP, WST_ETH } from '../../contracts';
import { ZERO_W3N } from '../../constants';
import { LeverSimulation, simOutput } from '../useLever';
import { ethers } from 'ethers';

export const useStEthSim = ( ): simOutput => {
  const [ leverState ] = useContext(LeverContext);
  const [ marketState ]: [IPoolState] = useContext(MarketContext);
  const { selectedStrategy, provider } = leverState;
  const [ inputState ] = useContext(InputContext);
  const { input, leverage } = inputState
  
  const [isSimulating, setIsSimulating] = useState<boolean>(false);

  const inputAsFyToken: W3bNumber = useMemo(() => {
    if (input && input.big.gt(ZERO_BN)) {
      const fyTokens = sellBase(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        input.big,
        getTimeToMaturity(marketState.maturity),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      return convertToW3bNumber(fyTokens, 18, 6);
    }
    return ZERO_W3N;
  }, [input, marketState]);

  const totalToInvest: W3bNumber = useMemo(() => {
    if (inputAsFyToken.big.gt(ZERO_BN)) {
      const total_ = inputAsFyToken.big.mul(leverage!.big).div(100);
      return convertToW3bNumber(total_, 18, 6); /* set as w3bnumber  */
    }
    return ZERO_W3N;
  }, [inputAsFyToken, leverage]);

  const toBorrow: W3bNumber = useMemo(() => {
    if (inputAsFyToken) {
      const toBorrow_ = totalToInvest.big.sub(inputAsFyToken.big);
      return convertToW3bNumber(toBorrow_, 18, 6); /* set as w3bNumber */
    }
    return ZERO_W3N;
  }, [totalToInvest]);


  /**
   * Compute how much collateral would be generated by investing with these
   * parameters.
   */
  const simulateLever =  async (): Promise<LeverSimulation> => {
    
    const shortBorrowed = toBorrow;
    let investPosition = ZERO_W3N;
    let investValue= ZERO_W3N;
    let shortInvested= ZERO_W3N;
    let flashFee= ZERO_W3N;
    let debtPosition= ZERO_W3N;
    let debtValue= ZERO_W3N;

    if (selectedStrategy && inputAsFyToken.big.gt(ZERO_BN) ) {

      setIsSimulating(true);
      // - netInvestAmount = baseAmount + borrowAmount - fee
      // const fyWeth = await getFyToken(seriesId, contracts, account);
      const fyContract = selectedStrategy.investTokenContract;
      const fee = await fyContract.flashFee(fyContract.address, toBorrow.big.toString());
      flashFee = convertToW3bNumber(fee.toString(), 18, 6);
      
      /* calculate the resulting debt */
      const debt_ = sellBase(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        toBorrow.big,
        getTimeToMaturity(marketState.maturity),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      debtPosition = convertToW3bNumber(debt_, 18, 6)

      // const debtValue = 

      // - sellFyWeth: FyWEth -> WEth
      // const obtainedWEth = await selectedStrategy.marketContract.sellFYTokenPreview(netInvestAmount);
      const netInvestAmount = inputAsFyToken.big.add(toBorrow.big) // .sub(fee); // - netInvestAmount = baseAmount + borrowAmount - fee
      const wethObtained = sellFYToken(
        marketState.sharesReserves,
        marketState.fyTokenReserves,
        netInvestAmount,
        getTimeToMaturity(marketState.maturity),
        marketState.ts,
        marketState.g1,
        marketState.decimals
      );
      shortInvested = convertToW3bNumber(wethObtained, 18, 6);


      // stableSwap exchange: WEth -> StEth
      const stableSwap = contractFactories[WETH_STETH_STABLESWAP].connect(WETH_STETH_STABLESWAP, provider);
      const boughtStEth = await stableSwap.get_dy(0, 1, wethObtained);

      // investPosition (stEth held)
      investPosition = convertToW3bNumber(boughtStEth, 18, 6);

      // - Wrap: StEth -> WStEth
      const wStEthContract = contractFactories[WST_ETH].connect(WST_ETH, provider);
      // const investPosition_ = await wStEthContract.getWstETHByStETH(boughtStEth);
      // console.log( 'WrappedStETH : ',  investPosition_.toString() )
      // console.log( 'WrappedStETH : ',  investPosition_.toString() )

      // check unwrapping  */
      const oneStEth = ethers.utils.parseUnits('1')
      const stEthPerWrapped = await wStEthContract.getStETHByWstETH( oneStEth )
      
      const unwrappedStEthValue = boughtStEth.mul(stEthPerWrapped).div(oneStEth);

      console.log( stEthPerWrapped.toString()  )
      console.log( 'UNWRAPEED STEEHT : ', unwrappedStEthValue.toString()  )
      
      /* check for anywswapping cost */
      /* Calculate the value of the investPosition in short terms : via swap */
      const investValue_ = await stableSwap.get_dy(1, 0, boughtStEth);
      investValue = convertToW3bNumber(investValue_, 18, 6)

    }

    setIsSimulating(false);

    return {
      investPosition,
      investValue,
      shortBorrowed,
      shortInvested,
      flashFee,
      debtPosition,
      debtValue,
    }
  };

  return { simulateLever, isSimulating, notification:[], extraBucket:[] }

};
